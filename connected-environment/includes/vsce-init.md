## Initialize code for Docker and Kubernetes development
So far, we have a basic web app that can run locally. We'll now containerize it by creating assets that define the app's container and how it will deploy to Kubernetes. This is easy to do with Connected Environment: 

1. Launch VS Code and open the `webfrontend` folder. (You can ignore any default prompts to add debug assets or restore the project.)
1. Open the Integrated Terminal in VS Code (using the **View | Integrated Terminal** menu).
1. Run this command (be sure that **webfrontend** is your current folder):

```cmd
vsce init --public
```

The Connected Environment CLI's ```init``` command generates Docker and Kubernetes assets with default settings:
* `./Dockerfile` describes the app's container image, and how the source code is built and runs within the container.
* A [Helm chart](https://docs.helm.sh) under `./charts/webfrontend` describes how to deploy the container to Kubernetes.

For now it isn't necessary to understand the full content of these files. It's worth pointing out, however, that **the same Kubernetes and Docker configuration-as-code assets can be used from development through to production, thus providing better consistency across different environments.**
 
A file named `./vsce.yaml` is also generated by the `init` command, and it is the configuration file for Connected Environment. It complements the Docker and Kubernetes artifacts with additional configuration that enables an iterative development experience in Azure. For example, the default Helm chart does not expose any public endpoints. Sometimes, however, it is useful to temporarily open up a public endpoint during development so you can test your code, say, from a mobile device or a webhook URL. A vsce.yaml file created using `init --public` overrides the Helm default parameters to expose a public endpoint for development time only.
